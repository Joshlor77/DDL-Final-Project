#include "NoteOutput.h"
#include "FIO.h"
#include "Timer.h"

/* Usage Guideline
 * call SetChInterval to change the note frequency
 * call enableCh to play the note
 * call disableCh to stop playing the note
 * Implement the togglePin functions to use whichever IOpin as the square wave output.
 * 
 * For now the only outputs are square waves generated by timed interrupts.
 * Square waves are 50% duty cycle
 * 
 */

#define ISER0 (*(volatile unsigned int *) 0xE000E100)

void initNoteSystem(void){
    T0.IR = 0xF;          //Clear MR Interupt flags
    T0.TCR |= 1;          //Enable Timer0 counter
    ISER0 = (1 << 1);     //Enable Timer0 interrupts

	//Set P0.2 and P0.3 as outputs and set no pull resistors
	FIO[0].DIR |= (3 << 2);
	PINMODE[0] |= (0xA << 4);
	//Set P0.21 and P0.22 as outputs and set no pull resistors
	FIO[0].DIR |= (3 << 21);
	PINMODE[1] |= (0xA << 10);
}

/* Contains the time intervals for each Match Register
 * This is used to update the Match Register during the interrupt handler for the next interrupt.
 * To achieve an output at a frequency f the interval value is
 * Value = PCLK / (2f)
 */
unsigned int ChInterval[4];

static void enableMCRInterrupt(int MR){
    switch (MR) {
    case 0:
        T0.MCR |= 1;
        return;
    case 1:
        T0.MCR |= (1 << 3);
        return;
    case 2:
        T0.MCR |= (1 << 6);
        return;
    case 3:
        T0.MCR |= (1 << 9);
    	return;
    default:
    	return;
    }
}

// Enables interrupt generation from the specified match register
void enableCh(int MR){
	enableMCRInterrupt(MR);
    T0.MR[MR] = T0.TC + ChInterval[MR];
}

// Changes the interval for the Match Register
void setChInterval(int MR, unsigned int interval){
    ChInterval[MR] = interval;
}

/* Disables interrupt generation from the specified Match Register.
 * Also clears the relevant interrupt flag.
 */
void disableCh(int MR){
    T0.IR = (1 << MR);
    switch (MR) {
    case 0:
        T0.MCR |= 1;
        return;
    case 1:
        T0.MCR |= (1 << 3);
        return;
    case 2:
        T0.MCR |= (1 << 6);
        return;
    case 3:
        T0.MCR |= (1 << 9);
    	return;
    default:
    	return;
    }
}

int pinState [] = {1, 1, 1, 1};
void togglePin0(){
	if (pinState[0])
		FIO[0].SET |= (1 << 2);
	else
		FIO[0].CLR |= (1 << 2);
	pinState[0] = !pinState[0];
}
void togglePin1(){
	if (pinState[1])
		FIO[0].SET |= (1 << 3);
	else
		FIO[0].CLR |= (1 << 3);
	pinState[1] = !pinState[1];
}
void togglePin2(){
	if (pinState[2])
		FIO[0].SET |= (1 << 21);
	else
		FIO[0].CLR |= (1 << 21);
	pinState[2] = !pinState[2];
}
void togglePin3(){
	if (pinState[3])
		FIO[0].SET |= (1 << 22);
	else
		FIO[0].CLR |= (1 << 22);
	pinState[3] = !pinState[3];
}

void TIMER0_IRQHandler(void){
    if (T0.IR & 1){
        T0.IR = 1;
        T0.MR[0] += ChInterval[0];
        togglePin0();
    }
    if (T0.IR & 2){
        T0.IR = 2;
        T0.MR[1] += ChInterval[1];
        togglePin1();
    }
    if (T0.IR & 4){
        T0.IR = 4;
        T0.MR[2] += ChInterval[2];
        togglePin2();
    }
    if (T0.IR & 8){
        T0.IR = 8;
        T0.MR[3] += ChInterval[3];
        togglePin3();
    }
}
